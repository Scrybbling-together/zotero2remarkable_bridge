import types
from _typeshed import Incomplete
from io import BufferedReader as BufferedReader, FileIO as FileIO
from webdav3.connection import WebDAVSettings as WebDAVSettings
from webdav3.exceptions import (
    ConnectionException as ConnectionException,
    LocalResourceNotFound as LocalResourceNotFound,
    MethodNotSupported as MethodNotSupported,
    NoConnection as NoConnection,
    NotEnoughSpace as NotEnoughSpace,
    OptionNotValid as OptionNotValid,
    RemoteParentNotFound as RemoteParentNotFound,
    RemoteResourceNotFound as RemoteResourceNotFound,
    ResourceLocked as ResourceLocked,
    ResponseErrorCode as ResponseErrorCode,
)
from webdav3.urn import Urn as Urn

log: Incomplete

def listdir(directory): ...
def get_options(option_type, from_options): ...
def wrap_connection_error(fn): ...

class Client:
    root: str
    verify: bool
    default_http_header: Incomplete
    default_requests: Incomplete
    meta_xmlns: Incomplete
    session: Incomplete
    http_header: Incomplete
    requests: Incomplete
    webdav: Incomplete
    default_options: Incomplete
    timeout: Incomplete
    chunk_size: int
    def __init__(self, options) -> None: ...
    def get_headers(self, action, headers_ext=None): ...
    def get_url(self, path): ...
    def get_full_path(self, urn): ...
    def execute_request(self, action, path, data=None, headers_ext=None): ...
    def valid(self): ...
    @wrap_connection_error
    def list(
        self, remote_path=..., get_info: bool = False, recursive: bool = False
    ): ...
    @wrap_connection_error
    def free(self): ...
    @wrap_connection_error
    def check(self, remote_path=...): ...
    @wrap_connection_error
    def mkdir(self, remote_path, recursive: bool = False): ...
    @wrap_connection_error
    def download_iter(self, remote_path): ...
    @wrap_connection_error
    def download_from(
        self, buff, remote_path, progress=None, progress_args=()
    ) -> None: ...
    def download(
        self, remote_path, local_path, progress=None, progress_args=()
    ) -> None: ...
    def download_directory(
        self, remote_path, local_path, progress=None, progress_args=()
    ) -> None: ...
    @wrap_connection_error
    def download_file(
        self, remote_path, local_path, progress=None, progress_args=()
    ) -> None: ...
    def download_sync(
        self, remote_path, local_path, callback=None, progress=None, progress_args=()
    ) -> None: ...
    def download_async(
        self, remote_path, local_path, callback=None, progress=None, progress_args=()
    ): ...
    @wrap_connection_error
    def upload_iter(self, read_callback, remote_path) -> None: ...
    @wrap_connection_error
    def upload_to(self, buff, remote_path) -> None: ...
    def upload(
        self, remote_path, local_path, progress=None, progress_args=()
    ) -> None: ...
    def upload_directory(
        self, remote_path, local_path, progress=None, progress_args=()
    ) -> None: ...
    @wrap_connection_error
    def upload_file(
        self,
        remote_path,
        local_path,
        progress=None,
        progress_args=(),
        force: bool = False,
    ) -> None: ...
    def upload_sync(
        self, remote_path, local_path, callback=None, progress=None, progress_args=()
    ) -> None: ...
    def upload_async(
        self, remote_path, local_path, callback=None, progress=None, progress_args=()
    ): ...
    @wrap_connection_error
    def copy(self, remote_path_from, remote_path_to, depth: int = 1) -> None: ...
    @wrap_connection_error
    def move(
        self, remote_path_from, remote_path_to, overwrite: bool = False
    ) -> None: ...
    @wrap_connection_error
    def clean(self, remote_path) -> None: ...
    @wrap_connection_error
    def info(self, remote_path): ...
    @wrap_connection_error
    def is_dir(self, remote_path): ...
    @wrap_connection_error
    def get_property(self, remote_path, option): ...
    @wrap_connection_error
    def set_property(self, remote_path, option) -> None: ...
    @wrap_connection_error
    def set_property_batch(self, remote_path, option) -> None: ...
    @wrap_connection_error
    def lock(self, remote_path=..., timeout: int = 0): ...
    def resource(self, remote_path): ...
    def push(self, remote_directory, local_directory): ...
    def pull(self, remote_directory, local_directory): ...
    def is_local_more_recent(self, local_path, remote_path): ...
    def sync(self, remote_directory, local_directory) -> None: ...

class Resource:
    client: Incomplete
    urn: Incomplete
    def __init__(self, client, urn) -> None: ...
    def is_dir(self): ...
    def rename(self, new_name) -> None: ...
    def move(self, remote_path) -> None: ...
    def copy(self, remote_path): ...
    def info(self, params=None): ...
    def clean(self): ...
    def check(self): ...
    def read_from(self, buff) -> None: ...
    def read(self, local_path): ...
    def read_async(self, local_path, callback=None): ...
    def write_to(self, buff): ...
    def write(self, local_path): ...
    def write_async(self, local_path, callback=None): ...
    def publish(self): ...
    def unpublish(self): ...
    def get_property(self, option): ...
    def set_property(self, option, value) -> None: ...

class WebDavXmlUtils:
    def __init__(self) -> None: ...
    @staticmethod
    def parse_get_list_info_response(content): ...
    @staticmethod
    def parse_get_list_response(content): ...
    @staticmethod
    def create_free_space_request_content(): ...
    @staticmethod
    def parse_free_space_response(content, hostname): ...
    @staticmethod
    def get_info_from_response(response): ...
    @staticmethod
    def parse_info_response(content, path, hostname): ...
    @staticmethod
    def parse_is_dir_response(content, path, hostname): ...
    @staticmethod
    def create_get_property_request_content(option): ...
    @staticmethod
    def parse_get_property_response(content, name): ...
    @staticmethod
    def create_set_property_batch_request_content(options): ...
    @staticmethod
    def etree_to_string(tree): ...
    @staticmethod
    def extract_response_for_path(content, path, hostname): ...

class LockClient(Client):
    session: Incomplete
    webdav: Incomplete
    requests: Incomplete
    timeout: Incomplete
    def __init__(self, client, lock_path, lock_token) -> None: ...
    def get_headers(self, action, headers_ext=None): ...
    def __enter__(self): ...
    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: types.TracebackType | None,
    ) -> None: ...
